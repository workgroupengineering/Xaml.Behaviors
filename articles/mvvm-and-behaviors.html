<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>MVVM and Behaviors | XAML Behaviors for Avalonia </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="MVVM and Behaviors | XAML Behaviors for Avalonia ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/workgroupengineering/Xaml.Behaviors/blob/master/docfx/articles/mvvm-and-behaviors.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="mvvm-and-behaviors">MVVM and Behaviors</h1>

<p>The Model-View-ViewModel (MVVM) pattern is the standard architectural pattern for Avalonia applications. While MVVM promotes a clean separation of concerns, it often presents a challenge: <strong>How do we handle View-specific events and logic without polluting the code-behind?</strong></p>
<p>Behaviors are the bridge that solves this problem.</p>
<h2 id="the-problem-with-code-behind">The Problem with Code-Behind</h2>
<p>In a strict MVVM application, the ViewModel should not know about the View types (like <code>Button</code>, <code>TextBox</code>, or <code>PointerEventArgs</code>). However, user interactions are inherently View-based.</p>
<p>Traditionally, you might write this in code-behind (<code>.axaml.cs</code>):</p>
<pre><code class="lang-csharp">private void OnTextBoxKeyDown(object sender, KeyEventArgs e)
{
    if (e.Key == Key.Enter)
    {
        (DataContext as MyViewModel)?.SubmitCommand.Execute(null);
    }
}
</code></pre>
<p><strong>Drawbacks:</strong></p>
<ol>
<li><strong>Coupling</strong>: The View is tightly coupled to the logic.</li>
<li><strong>Testability</strong>: You cannot easily unit test this logic without instantiating the View.</li>
<li><strong>Reusability</strong>: If you need this &quot;Enter key submits&quot; logic elsewhere, you have to copy-paste the code.</li>
</ol>
<h2 id="the-solution-behaviors">The Solution: Behaviors</h2>
<p>Behaviors allow you to encapsulate this logic into reusable XAML components.</p>
<pre><code class="lang-xml">&lt;TextBox&gt;
    &lt;Interaction.Behaviors&gt;
        &lt;EventTriggerBehavior EventName=&quot;KeyDown&quot;&gt;
            &lt;InvokeCommandAction Command=&quot;{Binding SubmitCommand}&quot; /&gt;
        &lt;/EventTriggerBehavior&gt;
    &lt;/Interaction.Behaviors&gt;
&lt;/TextBox&gt;
</code></pre>
<h3 id="benefits-of-using-behaviors">Benefits of Using Behaviors</h3>
<ol>
<li><strong>Declarative UI</strong>: The behavior of the control is defined alongside its layout in XAML. You can see <em>what</em> the control does just by reading the markup.</li>
<li><strong>Reusability</strong>: A behavior like <code>EventTriggerBehavior</code> works on <em>any</em> control with an event. You write the logic once and apply it everywhere.</li>
<li><strong>Separation of Concerns</strong>:
<ul>
<li><strong>ViewModel</strong>: Handles business logic and state (<code>SubmitCommand</code>).</li>
<li><strong>View</strong>: Handles layout and visual structure.</li>
<li><strong>Behavior</strong>: Handles the <em>interaction</em> between the user and the View, translating events into Commands.</li>
</ul>
</li>
<li><strong>No Code-Behind</strong>: You can often achieve complex interactions (drag-and-drop, focus management, scrolling) with zero lines of code-behind.</li>
</ol>
<h2 id="when-to-use-behaviors-vs-other-techniques">When to Use Behaviors vs. Other Techniques</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Technique</th>
<th style="text-align: left;">Use Case</th>
<th style="text-align: left;">Pros</th>
<th style="text-align: left;">Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Behaviors</strong></td>
<td style="text-align: left;">View interactions, event-to-command translation, reusable UI logic (e.g., drag-and-drop).</td>
<td style="text-align: left;">Reusable, declarative, MVVM-friendly.</td>
<td style="text-align: left;">Adds a slight runtime overhead compared to raw events.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Code-Behind</strong></td>
<td style="text-align: left;">Highly specific, non-reusable View logic that doesn't affect the ViewModel (e.g., complex canvas drawing).</td>
<td style="text-align: left;">Simple, direct access to API.</td>
<td style="text-align: left;">Hard to test, hard to reuse, breaks MVVM purity.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Attached Properties</strong></td>
<td style="text-align: left;">Storing state on controls or simple property-change logic.</td>
<td style="text-align: left;">Lightweight.</td>
<td style="text-align: left;">Harder to manage complex lifecycles (events) than Behaviors.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Custom Controls</strong></td>
<td style="text-align: left;">Creating entirely new visual elements with their own templates.</td>
<td style="text-align: left;">Full control over rendering and API.</td>
<td style="text-align: left;">Heavyweight, requires creating themes/templates.</td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>Behaviors are an essential tool in the Avalonia developer's toolkit. They allow you to maintain the purity of the MVVM pattern while still delivering rich, interactive user experiences. By moving interaction logic out of code-behind and into reusable behaviors, you create a codebase that is cleaner, more maintainable, and easier to test.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/workgroupengineering/Xaml.Behaviors/blob/master/docfx/articles/mvvm-and-behaviors.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
